SourceCode with shared memory: 

#include<stdio.h>
#include <cuda.h>
#define N 9
#define R 2
__global__ void stencilshared(int *in, int *out, int rows, int radius) {
    __shared__ int tile[N];
    int x = threadIdx.x + blockIdx.x * blockDim.x;
    if (x < rows) {
        tile[threadIdx.x] = in[x];
    }
    __syncthreads();
    if (x < rows) {
        int i = threadIdx.x - radius;
        if (i < 0) {
                i=0;
        }
        int j = threadIdx.x + radius;
        if (j >= rows) {
                j = rows - 1;
        }
        for (int k=i;k<=j;k++) {
                out[threadIdx.x] += tile[k];
        }
    __syncthreads();
    }
}
int main() {
    int h_in[N] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int h_out[N] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    int *d_in, *d_out;
    size_t size = N * sizeof(float);
    cudaMalloc(&d_in, size);
    cudaMalloc(&d_out, size);
    cudaMemcpy(d_in, h_in, size, cudaMemcpyHostToDevice);
    dim3 dimBlock(N, 1);
    dim3 dimGrid(1, 1);
    cudaEvent_t start, stop;
    cudaEventCreate(&start);
    cudaEventCreate(&stop);
    cudaEventRecord(start);
    stencilshared<<<dimGrid, dimBlock>>>(d_in, d_out, N, R);
    cudaEventRecord(stop);
    cudaEventSynchronize(stop);
    float milliseconds = 0;
    cudaEventElapsedTime(&milliseconds, start, stop);
    cudaMemcpy(h_out, d_out, size, cudaMemcpyDeviceToHost);
    printf("Original matrix:\n");
    for (int i = 0; i < N; i++) {
        printf("%d ", h_in[i]);
    }
    printf("\nResult array:\n");
    for (int i = 0; i < N; i++) {
        printf("%d ", h_out[i]);
    }
    printf("\nExecution time (CUDA): %f ms\n", milliseconds);
    cudaFree(d_in);
    cudaFree(d_out);
    cudaEventDestroy(start);
    cudaEventDestroy(stop);
    return 0;
}

Sample output:

Original matrix:
1 2 3 4 5 6 7 8 9
Result array:
6 10 15 20 25 30 35 30 24
Execution time (CUDA): 212.829178 ms
